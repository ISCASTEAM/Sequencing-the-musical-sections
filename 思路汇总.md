
论文要点分析: https://github.com/ISCASTEAM/Sequencing-the-musical-sections   
   
i. 动机  
```
    三个音乐片段，如何按照播放时间的顺序进行正确的排列？   
    SEN: 两两片段计算相似度，按照组合相似度最大的排列认定为正确的排列。   
    举例: （Pa，Pb，Pc）考虑前后顺序共有6个片段对；P（b，a，c）= P(b，a) + P(a，c)思路，寻找最大的组合。    
```  
  
ii. 本文的创新点   
```      
    a. 借鉴SEN方式，对于相似度矩阵进行卷积+pooling。   
    b. 输入格式从二元组扩展至三元组，增强模型学习全局信息的能力。   
```
   
iii. 网络计算流程   
```
    a. 输入音频片段，通过librosa库转换为黑白的频谱图 [bs, 1, 345, 128] = channel，Width，Height   
    b. 三层卷积共享参数计算Feature_Map   
    c. Feature_Map计算相似度矩阵   
    Feature_Map =【bs，channel，Width，1】； Matrix = 【bs，filter_num，filter_num】   
```   
   
d. 相似度矩阵求平均   
```   
    三元组的输入，会有两组pair对，会得到两组相似度矩阵。通过求平均的方式，变为一个相似度矩阵。   
    #reshape，相似度矩阵相当于channel=1的图像 ([10, 1, 336, 336])   
    fms = torch.unsqueeze(torch.div(num,denom),dim=1)   
```   
   
e. 相似度矩阵进行卷积&池化计算   
```   
    输出: [bs, 258, width, height]； 通过avg池化，得到[bs, 258, width, 1]   
```      
   
f. LSTM网络捕捉时序信息     
```   
    获取最后一步的时序信息，outLstm[:,-1,:]，输出:[bs，1，width]  
```   
     
g. 全连接层分类   
   
  